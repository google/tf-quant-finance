<!--
This file is generated by a tool. Do not edit directly.
For open-source contributions the docs will be updated automatically.
-->

*Last updated: 2022-11-30.*

<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf_quant_finance.experimental.american_option_pricing.andersen_lake.calculate_exercise_boundary" />
<meta itemprop="path" content="Stable" />
</div>

# tf_quant_finance.experimental.american_option_pricing.andersen_lake.calculate_exercise_boundary

<!-- Insert buttons and diff -->

<table class="tfo-notebook-buttons tfo-api" align="left">
</table>

<a target="_blank" href="https://github.com/google/tf-quant-finance/blob/master/tf_quant_finance/experimental/american_option_pricing/exercise_boundary.py">View source</a>



Calculates the exercise boundary function of an American option.

```python
tf_quant_finance.experimental.american_option_pricing.andersen_lake.calculate_exercise_boundary(
    tau_grid, k, r, q, sigma, max_iterations=20, tolerance=1e-08,
    integration_num_points=32, dtype=None
)
```



<!-- Placeholder for "Used in" -->

Iteratively calculates the exercise boundary function of an American option.
This corresponds to `B` in formula (3.9) in the paper [1].

#### References
[1] Leif Andersen, Mark Lake and Dimitri Offengenden. High-performance
American option pricing. 2015
https://engineering.nyu.edu/sites/default/files/2019-03/Carr-adjusting-exponential-levy-models.pdf#page=55

#### Example
```python
  tau = tf.constant([0.01, 0.02, 1], dtype=tf.float64)
  k = tf.constant([1, 2, 3], dtype=tf.float64)
  r = tf.constant([0.01, 0.02, 0.035], dtype=tf.float64)
  q = tf.constant([0.01, 0.02, 0.07], dtype=tf.float64)
  sigma = tf.constant([0.1, 0.15, 0.32], dtype=tf.float64)
  grid_num_points = 40
  max_iterations = 600
  tolerance = 1e-8
  integration_num_points = 32
  tau_grid = tf.linspace(tf.constant(0.0001, dtype=tf.float64), tau,
                        grid_num_points, axis=-1)
  exercise_boundary(tau_grid, k, r, q, sigma, max_iterations, tolerance,
                    integration_num_points)
  # Returns a tensor of shape [3, 40].
```

#### Args:


* <b>`tau_grid`</b>: Grid of values of shape `[num_options, grid_num_points]`
  indicating the time left until option maturity.
* <b>`k`</b>: Same dtype as `tau_grid` with shape `num_options` representing the strike
  price of the option.
* <b>`r`</b>: Same shape and dtype as `k` representing the annualized risk-free
  interest rate, continuously compounded.
* <b>`q`</b>: Same shape and dtype as `k` representing the dividend rate.
* <b>`sigma`</b>: Same shape and dtype as `k` representing the volatility of the
  option's returns.
* <b>`max_iterations`</b>: Maximum number of iterations for calculating the exercise
  boundary if it doesn't converge earlier. Default value: 20.
* <b>`tolerance`</b>: Represents the tolerance for the relative difference between the
  old and new exercise boundary function values, at which to stop further
  calculating a new exercise boundary function.
* <b>`integration_num_points`</b>: The number of points used in the integration
  approximation method.
  Default value: 32.
* <b>`dtype`</b>: If supplied, the dtype for all input tensors. Result will have the
  same dtype.
  Default value: None which maps to dtype of `tau`.


#### Returns:

`Callable` expecting `Tensor` of shape `[num_options, n]` as input (where
`n` is an arbitrary integer)  and returning `Tensor` of the same shape.
Represents the exercise boundary function of an American option pricing
algorithm.
