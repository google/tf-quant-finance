<!--
This file is generated by a tool. Do not edit directly.
For open-source contributions the docs will be updated automatically.
-->

*Last updated: 2023-02-08.*

<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf_quant_finance.black_scholes.asian_option_price" />
<meta itemprop="path" content="Stable" />
</div>

# tf_quant_finance.black_scholes.asian_option_price

<!-- Insert buttons and diff -->

<table class="tfo-notebook-buttons tfo-api" align="left">
</table>

<a target="_blank" href="https://github.com/google/tf-quant-finance/blob/master/tf_quant_finance/black_scholes/asian_prices.py">View source</a>



Computes the Black Scholes price for a batch of asian options.

```python
tf_quant_finance.black_scholes.asian_option_price(
    *, volatilities, strikes, expiries, spots=None, forwards=None,
    sampling_times=None, past_fixings=None, discount_rates=None,
    dividend_rates=None, discount_factors=None, is_call_options=None,
    is_normal_volatility=False,
    averaging_type=tf_quant_finance.black_scholes.AveragingType.GEOMETRIC,
    averaging_frequency=tf_quant_finance.black_scholes.AveragingFrequency.DISCRETE,
    dtype=None, name=None
)
```



<!-- Placeholder for "Used in" -->

In Black-Scholes, the marginal distribution of the underlying at each sampling
date is lognormal. The product of a sequence of lognormal variables is also
lognormal so we can re-express these options as vanilla options with modified
parameters and use the vanilla pricer to price them.

TODO(b/261568763): support volatility term structures


#### Example

```python
  # Price a batch of 5 seasoned discrete geometric Asian options.
  volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])
  forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
  # Strikes will automatically be broadcasted to shape [5].
  strikes = np.array([3.0])
  # Expiries will be broadcast to shape [5], i.e. each option has strike=3
  # and expiry = 1.
  expiries = 1.0
  sampling_times = np.array([[0.5, 0.5, 0.5, 0.5, 0.5],
                             [1.0, 1.0, 1.0, 1.0, 1.0]])
  past_fixings = np.array([[1.0, 2.0, 3.0, 4.0, 5.0]])
  computed_prices = tff.black_scholes.asian_option_price(
      volatilities=volatilities,
      strikes=strikes,
      expiries=expiries,
      forwards=forwards,
      sampling_times=sampling_times,
      past_fixings=past_fixings)
# Expected print output of computed prices:
# [ 0.0, 0.0, 0.52833763, 0.99555802, 1.91452834]
```

#### References:
[1] Haug, E. G., The Complete Guide to Option Pricing Formulas. McGraw-Hill.

#### Args:


* <b>`volatilities`</b>: Real `Tensor` of any shape compatible with a `batch_shape` and
  and anyy real dtype. The volatilities to expiry of the options to price.
  Here `batch_shape` corresponds to a batch of priced options.
* <b>`strikes`</b>: A real `Tensor` of the same dtype and compatible shape as
  `volatilities`. The strikes of the options to be priced.
* <b>`expiries`</b>: A real `Tensor` of same dtype and compatible shape as
  `volatilities`. The expiry of each option. The units should be such that
  `expiry * volatility**2` is dimensionless.
* <b>`spots`</b>: A real `Tensor` of any shape that broadcasts to the shape of the
  `volatilities`. The current spot price of the underlying. Either this
  argument or the `forwards` (but not both) must be supplied.
* <b>`forwards`</b>: A real `Tensor` of any shape that broadcasts to the shape of
  `volatilities`. The forwards to maturity. Either this argument or the
  `spots` must be supplied but both must not be supplied.
* <b>`sampling_times`</b>: A real `Tensor` of same dtype as expiries and shape `[n] +
  batch_shape` where n is the number of sampling times for the Asian options
  Default value: `None`, which will raise an error for discrete sampling
  Asian options
* <b>`past_fixings`</b>: A real `Tensor` of same dtype as spots or forwards and shape
  `[n] + batch_shape` where n is the number of past fixings that have
  already been observed.
  Default value: `None`, equivalent to no past fixings (ie. unseasoned)
* <b>`discount_rates`</b>: An optional real `Tensor` of same dtype as the
  `volatilities` and of the shape that broadcasts with `volatilities`. If
  not `None`, discount factors are calculated as e^(-rT), where r are the
  discount rates, or risk free rates. At most one of `discount_rates` and
  `discount_factors` can be supplied.
  Default value: `None`, equivalent to `r = 0` and `discount factors = 1`
  when `discount_factors` also not given.
* <b>`dividend_rates`</b>: An optional real `Tensor` of same dtype as the
  `volatilities` and of the shape that broadcasts with `volatilities`.
  Default value: `None`, equivalent to q = 0.
* <b>`discount_factors`</b>: An optional real `Tensor` of same dtype as the
  `volatilities`. If not `None`, these are the discount factors to expiry
  (i.e. e^(-rT)). Mutually exclusive with `discount_rates`. If neither is
  given, no discounting is applied (i.e. the undiscounted option price is
  returned). If `spots` is supplied and `discount_factors` is not `None`
  then this is also used to compute the forwards to expiry. At most one of
  `discount_rates` and `discount_factors` can be supplied.
  Default value: `None`, which maps to e^(-rT) calculated from
  `discount_rates`.
* <b>`is_call_options`</b>: A boolean `Tensor` of a shape compatible with
  `volatilities`. Indicates whether the option is a call (if True) or a put
  (if False). If not supplied, call options are assumed.
* <b>`is_normal_volatility`</b>: An optional Python boolean specifying whether the
  `volatilities` correspond to lognormal Black volatility (if False) or
  normal Black volatility (if True).
  Default value: False, which corresponds to lognormal volatility.
* <b>`averaging_type`</b>: Enum value of AveragingType to select the averaging method
  for the payoff calculation.
  Default value: AveragingType.GEOMETRIC
* <b>`averaging_frequency`</b>: Enum value of AveragingFrequency to select the
  averaging type for the payoff calculation (discrete vs continuous)
  Default value: AveragingFrequency.DISCRETE
* <b>`dtype`</b>: Optional `tf.DType`. If supplied, the dtype to be used for conversion
  of any supplied non-`Tensor` arguments to `Tensor`.
  Default value: `None` which maps to the default dtype inferred by
  TensorFlow.
* <b>`name`</b>: str. The name for the ops created by this function.
  Default value: `None` which is mapped to the default name
  `asian_option_price`.


#### Returns:


* <b>`option_prices`</b>: A `Tensor` of shape `batch_shape` and the same dtype as
`volatilities`. The Black Scholes price of the Asian options.


#### Raises:


* <b>`ValueError`</b>: If both `forwards` and `spots` are supplied or if neither is
  supplied.
* <b>`ValueError`</b>: If both `discount_rates` and `discount_factors` is supplied.
* <b>`ValueError`</b>: If `is_normal_volatility` is true and option is geometric, or
  `is_normal_volatility` is false (ie. lognormal) and option is arithmetic.
* <b>`ValueError`</b>: If option is discrete averaging and `sampling_dates` is None of
  if last sampling date is later than option expiry date.
* <b>`NotImplementedError`</b>: if option is continuous averaging.
* <b>`NotImplementedError`</b>: if option is arithmetic.